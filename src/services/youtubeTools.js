// ==========================================================================//  üé• youtubeTools.js ‚Äî Zen YouTube Coach Pro//  Transcript Engine Ultra-Premium stile YouTube Summary//  Pipeline://   1) YouTube timedtext//   2) HTML captionTracks (ytInitialPlayerResponse)//   3) Whisper (audio ‚Üí testo) via OpenAI//   4) AI Summary (pseudo-trascrizione da titolo+descrizione)// ==========================================================================import axios from "axios";import ytdl from "ytdl-core";import FormData from "form-data";import dotenv from "dotenv";dotenv.config();const OPENAI_API_KEY = process.env.OPENAI_API_KEY || null;const transcriptCache = new Map();// ==========================================================================//  üîé Estrai videoId da URL YouTube// ==========================================================================export function extractYouTubeId(url) {  try {    if (!url) return null;    if (url.includes("youtu.be/")) {      return url.split("youtu.be/")[1].split("?")[0];    }    if (url.includes("watch?v=")) {      const params = new URL(url);      return params.searchParams.get("v");    }    if (url.includes("/shorts/")) {      return url.split("/shorts/")[1].split("?")[0];    }    return null;  } catch (error) {    console.error("‚ùå Errore estrazione videoId:", error);    return null;  }}// ==========================================================================//  üß† Livello 1 ‚Äî YouTube TimedText API// ==========================================================================async function fetchTimedText(videoId, lang = "it") {  try {    const url = `https://www.youtube.com/api/timedtext?lang=${lang}&v=${videoId}`;    const { data } = await axios.get(url, {      timeout: 8000,      responseType: "text",    });    if (!data || data.length < 10) return null;    let transcript = data      .replace(/<text start="([\d.]+)" dur="([\d.]+)">/g, "")      .replace(/<\/text>/g, "\n")      .replace(/&amp;/g, "&")      .replace(/&#39;/g, "'")      .replace(/&quot;/g, '"')      .replace(/<[^>]+>/g, "")      .trim();    if (transcript.length < 20) return null;    console.log("‚úÖ Transcript trovato via timedtext");    return transcript;  } catch (err) {    console.log("‚ö†Ô∏è timedtext non disponibile:", err.message);    return null;  }}// ==========================================================================//  üß† Livello 2 ‚Äî HTML captionTracks da ytInitialPlayerResponse// ==========================================================================async function fetchFromHtmlCaptions(videoId, preferredLangs = ["it", "en"]) {  try {    const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;    const { data: html } = await axios.get(watchUrl, {      timeout: 10000,      responseType: "text",      headers: {        "User-Agent":          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36",      },    });    const match = html.match(      /ytInitialPlayerResponse\s*=\s*({.*?});<\/script>/s    );    if (!match || match.length < 2) {      console.log("‚ö†Ô∏è ytInitialPlayerResponse non trovato nell'HTML");      return null;    }    let playerResponseRaw = match[1];    playerResponseRaw = playerResponseRaw.replace(/;$/, "");    let playerResponse;    try {      playerResponse = JSON.parse(playerResponseRaw);    } catch (err) {      console.log("‚ö†Ô∏è Errore parse ytInitialPlayerResponse:", err.message);      return null;    }    const captionTracks =      playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;    if (!captionTracks || !Array.isArray(captionTracks) || captionTracks.length === 0) {      console.log("‚ö†Ô∏è Nessun captionTrack trovato in ytInitialPlayerResponse");      return null;    }    let track = null;    for (const lang of preferredLangs) {      track = captionTracks.find((t) => t.languageCode === lang);      if (track) break;    }    if (!track) {      track = captionTracks[0];    }    if (!track?.baseUrl) {      console.log("‚ö†Ô∏è captionTrack senza baseUrl");      return null;    }    const { data } = await axios.get(track.baseUrl, {      timeout: 10000,      responseType: "text",    });    let transcript = data      .replace(/<text.*?>/g, "")      .replace(/<\/text>/g, "\n")      .replace(/<[^>]+>/g, "")      .replace(/&amp;/g, "&")      .replace(/&#39;/g, "'")      .replace(/&quot;/g, '"')      .trim();    if (!transcript || transcript.length < 20) {      console.log("‚ö†Ô∏è Transcript via HTML troppo corto o vuoto");      return null;    }    console.log("‚úÖ Transcript trovato via HTML/ytInitialPlayerResponse");    return transcript;  } catch (err) {    console.log("‚ö†Ô∏è Errore fetchFromHtmlCaptions:", err.message);    return null;  }}// ==========================================================================//  üìã Helper ‚Äî Metadati base dal HTML (titolo + descrizione)// ==========================================================================async function fetchVideoMetadata(videoId) {  try {    const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;    const { data: html } = await axios.get(watchUrl, {      timeout: 10000,      responseType: "text",      headers: {        "User-Agent":          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36",      },    });    let title = "";    const titleMatch = html.match(/<title>(.*?)<\/title>/i);    if (titleMatch && titleMatch[1]) {      title = titleMatch[1].replace(" - YouTube", "").trim();    }    let description = "";    const descMatch = html.match(      /"shortDescription":"(.*?)","isCrawlable"/s    );    if (descMatch && descMatch[1]) {      description = descMatch[1]        .replace(/\\n/g, " ")        .replace(/\\"/g, '"')        .replace(/\\\\/g, "\\")        .trim();    }    return { title, description };  } catch (err) {    console.log("‚ö†Ô∏è Errore fetchVideoMetadata:", err.message);    return { title: "", description: "" };  }}// ==========================================================================//  üéôÔ∏è Livello 3 ‚Äî Whisper (audio ‚Üí testo)// ==========================================================================async function fetchTranscriptWhisper(videoId, lang = "it") {  if (!OPENAI_API_KEY) {    console.log("‚ö†Ô∏è Nessuna OPENAI_API_KEY, Whisper disattivato");    return null;  }  try {    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;    console.log(`üéôÔ∏è Whisper: scarico audio da ${videoUrl}`);    const audioStream = ytdl(videoUrl, {      quality: "lowestaudio",      filter: "audioonly",    });    const chunks = [];    await new Promise((resolve, reject) => {      audioStream.on("data", (chunk) => chunks.push(chunk));      audioStream.on("end", resolve);      audioStream.on("error", reject);    });    const audioBuffer = Buffer.concat(chunks);    const form = new FormData();    form.append("file", audioBuffer, {      filename: `${videoId}.webm`,      contentType: "audio/webm",    });    form.append("model", "whisper-1");    form.append("language", lang);    const { data } = await axios.post(      "https://api.openai.com/v1/audio/transcriptions",      form,      {        headers: {          Authorization: `Bearer ${OPENAI_API_KEY}`,          ...form.getHeaders(),        },        timeout: 120000,      }    );    if (!data?.text) {      console.log("‚ö†Ô∏è Whisper non ha restituito testo");      return null;    }    console.log("‚úÖ Transcript ottenuto via Whisper");    return data.text;  } catch (err) {    console.log("‚ö†Ô∏è Errore Whisper:", err.message);    return null;  }}// ==========================================================================//  üß† Livello 4 ‚Äî AI Summary (pseudo-trascrizione)//  ‚ö†Ô∏è Nota: questo NON vede il video, usa titolo+descrizione per generare//  un testo strutturato che si comporta *come* una trascrizione plausibile.// ==========================================================================async function fetchTranscriptAISummary(videoId) {  if (!OPENAI_API_KEY) {    console.log("‚ö†Ô∏è Nessuna OPENAI_API_KEY, AI Summary disattivato");    return null;  }  try {    const { title, description } = await fetchVideoMetadata(videoId);    if (!title && !description) {      console.log("‚ö†Ô∏è Nessun metadata per AI Summary");      return null;    }    const prompt = `Ti do titolo e descrizione di un video YouTube.Titolo: ${title || "N/D"}Descrizione: ${description || "N/D"}Scrivi una pseudo-trascrizione PLAUSIBILE in italiano, come se stessitrascrivendo il contenuto del video, parlato in seconda persona singolare,stile educativo ma semplice.Non inventare cose assurde, resta aderente al tema evidente da titolo+descrizione.Non mettere timestamp o label di speaker. Solo testo continuo, ben strutturato in paragrafi brevi.    `.trim();    const payload = {      model: "gpt-4o-mini",      messages: [        {          role: "system",          content:            "Sei uno strumento che genera pseudo-trascrizioni plausibili per video YouTube, basandosi su titolo e descrizione.",        },        { role: "user", content: prompt },      ],      temperature: 0.4,    };    const { data } = await axios.post(      "https://api.openai.com/v1/chat/completions",      payload,      {        headers: {          Authorization: `Bearer ${OPENAI_API_KEY}`,          "Content-Type": "application/json",        },        timeout: 60000,      }    );    const text = data?.choices?.[0]?.message?.content?.trim();    if (!text) {      console.log("‚ö†Ô∏è AI Summary non ha restituito contenuto");      return null;    }    console.log("‚úÖ Pseudo-trascrizione generata via AI Summary");    return text;  } catch (err) {    console.log("‚ö†Ô∏è Errore AI Summary:", err.message);    return null;  }}// ==========================================================================//  üßπ Clean transcript// ==========================================================================function cleanTranscript(text) {  if (!text) return null;  return text    .replace(/\r/g, "")    .replace(/\n{2,}/g, "\n")    .replace(/\s{2,}/g, " ")    .trim();}// ==========================================================================//  üöÄ Funzione principale: PIPELINE COMPLETA// ==========================================================================export async function fetchTranscript(videoId, options = {}) {  try {    if (!videoId) return null;    if (transcriptCache.has(videoId)) {      return transcriptCache.get(videoId);    }    const preferredLangs = options.preferredLangs || ["it", "en"];    let transcript = null;    // 1Ô∏è‚É£ TimedText    transcript = await fetchTimedText(videoId, preferredLangs[0]);    if (transcript) {      transcript = cleanTranscript(transcript);      transcriptCache.set(videoId, transcript);      return transcript;    }    // 2Ô∏è‚É£ HTML captionTracks    transcript = await fetchFromHtmlCaptions(videoId, preferredLangs);    if (transcript) {      transcript = cleanTranscript(transcript);      transcriptCache.set(videoId, transcript);      return transcript;    }    // 3Ô∏è‚É£ Whisper (audio ‚Üí testo)    transcript = await fetchTranscriptWhisper(videoId, preferredLangs[0]);    if (transcript) {      transcript = cleanTranscript(transcript);      transcriptCache.set(videoId, transcript);      return transcript;    }    // 4Ô∏è‚É£ AI Summary (pseudo-trascrizione)    transcript = await fetchTranscriptAISummary(videoId);    if (transcript) {      transcript = cleanTranscript(transcript);      transcriptCache.set(videoId, transcript);      return transcript;    }    console.log("‚ùå Nessun livello pipeline √® riuscito a ottenere il transcript");    return null;  } catch (error) {    console.error("‚ùå Errore nella fetchTranscript:", error);    return null;  }}