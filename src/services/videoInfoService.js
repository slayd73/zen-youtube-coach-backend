// ======================================================// üé• videoInfoService.js ‚Äî Zen YouTube Coach Pro// ESTRAZIONE DATI VIDEO YOUTUBE (NO API KEY, NO COSTI)// ======================================================import dotenv from "dotenv";dotenv.config();/** * Funzione principale * @param {string} videoId * @returns {Promise<{ok:boolean, error?:string, data?:object}>} */export async function getVideoInfo(videoId) {  try {    if (!videoId) {      return { ok: false, error: "Missing videoId" };    }    const url = `https://www.youtube.com/watch?v=${videoId}`;    const html = await fetch(url).then((r) => r.text());    if (!html) {      return { ok: false, error: "Unable to fetch YouTube page" };    }    // ------------------------------------------------------    // üß© Estrai ytInitialPlayerResponse dal codice HTML    // ------------------------------------------------------    const playerResponse = extractInitialPlayerResponse(html);    if (!playerResponse) {      return {        ok: false,        error: "Unable to locate ytInitialPlayerResponse in HTML"      };    }    // ------------------------------------------------------    // üéØ Estrarre dati principali    // ------------------------------------------------------    const videoDetails = playerResponse.videoDetails || {};    const microformat = playerResponse.microformat?.playerMicroformatRenderer || {};    const info = {      videoId: videoDetails.videoId || videoId,      title: videoDetails.title || null,      description: videoDetails.shortDescription || null,      author: videoDetails.author || null,      channelId: videoDetails.channelId || null,      thumbnails: videoDetails.thumbnail?.thumbnails || [],      thumbnailHD: extractBestThumbnail(videoDetails),      durationSec: parseInt(videoDetails.lengthSeconds || microformat.lengthSeconds || 0),      tags: videoDetails.keywords || [],      isLive: videoDetails.isLive || false,      published: microformat.publishDate || null,      uploadDate: microformat.uploadDate || null    };    return { ok: true, data: info };  } catch (err) {    console.error("‚ùå videoInfoService ERROR:", err);    return {      ok: false,      error: err?.message || "Unknown error while fetching video info"    };  }}// ======================================================// üß† Estrai ytInitialPlayerResponse dal codice sorgente// ======================================================function extractInitialPlayerResponse(html) {  try {    const marker = "ytInitialPlayerResponse =";    const idx = html.indexOf(marker);    if (idx === -1) return null;    // taglia a partire dal marker    const start = idx + marker.length;    const sliced = html.slice(start);    // cerca la chiusura dell'oggetto JSON    const endIdx = sliced.indexOf(";</script>");    if (endIdx === -1) return null;    const jsonString = sliced.slice(0, endIdx).trim();    return JSON.parse(jsonString);  } catch (err) {    console.error("‚ùå extractInitialPlayerResponse ERROR:", err);    return null;  }}// ======================================================// üñºÔ∏è Trova la thumbnail pi√π alta disponibile// ======================================================function extractBestThumbnail(videoDetails = {}) {  try {    const thumbs = videoDetails?.thumbnail?.thumbnails;    if (!thumbs || !Array.isArray(thumbs)) return null;    // ordina per risoluzione    const sorted = thumbs.sort((a, b) => (b.width * b.height) - (a.width * a.height));    return sorted[0] || null;  } catch {    return null;  }}