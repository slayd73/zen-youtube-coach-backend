// ======================================================================// üß† transcriptUtils.js ‚Äî Versione 2025 Ultra-Premium// Utilities avanzate per la pulizia, normalizzazione e fusione segmenti// Compatibile con transcriptService.js + compare-transcript + analyze// ======================================================================// ---------------------------------------------------------------// 1Ô∏è‚É£ Riconoscimento timestamp tipo: 00:01 / 1:23 / 12:03:59// ---------------------------------------------------------------export function isTimestamp(str = "") {  return /^\d{1,2}:\d{2}(:\d{2})?$/.test(str.trim());}// ---------------------------------------------------------------// 2Ô∏è‚É£ Pulizia testo: rimuove rumore, tag, doppi spazi, timestamp mixati// ---------------------------------------------------------------export function cleanText(text = "") {  return String(text)    .replace(/<[^>]+>/g, " ")            // Tag HTML/XML    .replace(/\[[^\]]+\]/g, " ")         // [music], [applause], ecc.    .replace(/\(\d+:\d+\)/g, " ")         // Timestamp in parentesi    .replace(/\d{1,2}:\d{2}(:\d{2})?/g, "") // Timestamp qualsiasi    .replace(/\s+/g, " ")                // Spazi multipli    .trim();}// ---------------------------------------------------------------// 3Ô∏è‚É£ Normalizza segmenti YouTube (oggetto ‚Üí testo pulito coerente)// ---------------------------------------------------------------export function normalizeSegments(segments = []) {  if (!Array.isArray(segments)) return [];  return segments    .map((s) => {      if (!s) return null;      let text = "";      // Caso 1: YouTube API restituisce: { text: "..." }      if (typeof s === "object" && s.text) text = s.text;      // Caso 2: stringa pura      if (typeof s === "string") text = s;      if (!text) return null;      const cleaned = cleanText(text);      if (!cleaned || cleaned.length < 1) return null;      return cleaned;    })    .filter(Boolean);}// ---------------------------------------------------------------// 4Ô∏è‚É£ Merge segmenti ‚Üí testo continuo// ---------------------------------------------------------------export function mergeSegmentsToText(segments = []) {  if (!Array.isArray(segments)) return "";  const cleaned = normalizeSegments(segments);  return cleaned    .join(" ")    .replace(/\s{2,}/g, " ")    .trim();}// ---------------------------------------------------------------// 5Ô∏è‚É£ Mini-SRT generator (non basato su tempi reali, solo sequenze)// ---------------------------------------------------------------export function segmentsToSRT(segments = []) {  const cleaned = normalizeSegments(segments);  if (!cleaned.length) return "";  return cleaned    .map((line, i) => {      const start = `00:00:${String(i).padStart(2, "0")},000`;      const end = `00:00:${String(i + 1).padStart(2, "0")},000`;      return `${i + 1}\n${start} --> ${end}\n${line}\n`;    })    .join("\n");}// ---------------------------------------------------------------// 6Ô∏è‚É£ Mini-VTT generator (stesso approccio finch√© non hai timestamp reali)// ---------------------------------------------------------------export function segmentsToVTT(segments = []) {  const cleaned = normalizeSegments(segments);  if (!cleaned.length) return "";  const header = "WEBVTT\n\n";  const body = cleaned    .map((line, i) => {      const start = `00:00:${String(i).padStart(2, "0")}.000`;      const end = `00:00:${String(i + 1).padStart(2, "0")}.000`;      return `${start} --> ${end}\n${line}\n`;    })    .join("\n");  return header + body;}// ---------------------------------------------------------------// 7Ô∏è‚É£ Funzione premium: deduplicazione + ricostruzione naturale// ---------------------------------------------------------------export function naturalParagraphsFromText(text = "", maxLen = 220) {  const cleaned = cleanText(text);  if (!cleaned) return [];  const sentences = cleaned.split(/(?<=[.!?])\s+/);  const paragraphs = [];  let buffer = [];  for (const sentence of sentences) {    buffer.push(sentence);    if (buffer.join(" ").length >= maxLen) {      paragraphs.push(buffer.join(" "));      buffer = [];    }  }  if (buffer.length) paragraphs.push(buffer.join(" "));  return paragraphs.map((p) => p.trim());}// ---------------------------------------------------------------// 8Ô∏è‚É£ Funzione Premium: controllo qualit√† transcript// ---------------------------------------------------------------export function validateTranscriptQuality(text = "") {  const length = text.length;  const wordCount = text.split(/\s+/).filter(Boolean).length;  return {    isTooShort: wordCount < 20,    isProbablyInvalid: wordCount < 5,    length,    wordCount,    score: (() => {      if (wordCount < 10) return 1;      if (wordCount < 50) return 3;      if (wordCount < 150) return 6;      if (wordCount < 500) return 8;      return 10;    })()  };}// ---------------------------------------------------------------// 9Ô∏è‚É£ Utility Premium: safeTrim (evita crash di undefined/null)// ---------------------------------------------------------------export function safeTrim(value) {  if (!value) return "";  return String(value).trim();}