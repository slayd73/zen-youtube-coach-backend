// ============================================================// üìä aiUsageLogger.js ‚Äî Tracciamento uso AI (OpenAI / Groq)// ============================================================import fs from "fs";import path from "path";const LOG_DIR = path.join(process.cwd(), "logs");const LOG_FILE = path.join(LOG_DIR, "ai-usage.log");// Assicura che la cartella logs esistafunction ensureLogDir() {  if (!fs.existsSync(LOG_DIR)) {    fs.mkdirSync(LOG_DIR, { recursive: true });  }}/** * Registra una chiamata AI su file (formato JSON per riga) * * expectedEntry: * { *   provider: "openai" | "groq" | "unknown", *   model: "gpt-4o-mini" | "llama-3.1-70b-versatile" | string, *   route: "/generate/scriptPro" | "/analyze/transcript" | string, *   tokens_prompt: number, *   tokens_completion: number, *   cost_usd: number, *   success: boolean, *   error_message?: string, *   meta?: object * } */export function logAIUsage(expectedEntry = {}) {  try {    ensureLogDir();    const entry = {      timestamp: new Date().toISOString(),      provider: expectedEntry.provider || "unknown",      model: expectedEntry.model || "unknown",      route: expectedEntry.route || "unknown",      tokens_prompt: expectedEntry.tokens_prompt ?? null,      tokens_completion: expectedEntry.tokens_completion ?? null,      cost_usd: expectedEntry.cost_usd ?? null,      success: expectedEntry.success ?? true,      error_message: expectedEntry.error_message || null,      meta: expectedEntry.meta || null,    };    const line = JSON.stringify(entry);    fs.appendFile(LOG_FILE, line + "\n", (err) => {      if (err) {        console.error("‚ùå Errore salvataggio log AI:", err.message);      }    });  } catch (err) {    console.error("‚ùå logAIUsage fatal error:", err.message);  }}/** * Legge le ultime N righe del log e produce un riepilogo. * Non √® super ottimizzato, ma va benissimo per uso personale. */export function getUsageSummary(limit = 100) {  try {    if (!fs.existsSync(LOG_FILE)) {      return {        calls_total: 0,        by_provider: {},        by_model: {},        by_route: {},        last_calls: [],      };    }    const raw = fs.readFileSync(LOG_FILE, "utf8");    const lines = raw      .split("\n")      .map((l) => l.trim())      .filter((l) => l.length > 0);    const slice = lines.slice(-limit);    const last_calls = [];    const by_provider = {};    const by_model = {};    const by_route = {};    for (const line of slice) {      try {        const obj = JSON.parse(line);        last_calls.push(obj);        // provider        const p = obj.provider || "unknown";        by_provider[p] = (by_provider[p] || 0) + 1;        // model        const m = obj.model || "unknown";        by_model[m] = (by_model[m] || 0) + 1;        // route        const r = obj.route || "unknown";        by_route[r] = (by_route[r] || 0) + 1;      } catch {        // riga corrotta ‚Üí ignoro      }    }    return {      calls_total: lines.length,      calls_sampled: slice.length,      by_provider,      by_model,      by_route,      last_calls: last_calls.reverse(), // le pi√π recenti prima    };  } catch (err) {    console.error("‚ùå getUsageSummary error:", err.message);    return {      calls_total: 0,      by_provider: {},      by_model: {},      by_route: {},      last_calls: [],      error: err.message,    };  }}