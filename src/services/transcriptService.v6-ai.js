// ======================================================================// üéß transcriptService.js ‚Äî V6 Ultra-Premium 2025//// Pipeline definitiva per Zen YouTube Coach Pro://// PRIORIT√Ä:// 1) manualTranscript (incollato da te, dall'estensione, da YouTube, ecc.)// 2) YouTube TimedText (sottotitoli ufficiali)// 3) Proxy esterno (YT_TRANSCRIPT_PROXY_URL) se esiste// 4) YouTube Summary API esterna (YT_SUMMARY_API_URL) se esiste// 5) "Summary interno" via AI su titolo+descrizione// 6) Scraper HTML + noembed per contesto// 7) AI Transcript Rebuild + AI Cleanup// 8) Fallback testuale (mai pi√π errori duri)//// Tutto viene cache-ato in memoria per videoId.// ======================================================================import dotenv from "dotenv";import { callAIModel } from "./aiEngine.js";dotenv.config();// Cache in memoria (chiave: videoId normalizzato)const transcriptCache = new Map();// ======================================================================// üîß Normalizzazione ID / URL YouTube// ======================================================================function normalizeVideoId(input) {  if (!input) return null;  let v = String(input).trim();  // Se non √® URL, lo considero un ID grezzo e ripulisco da parametri  if (!v.startsWith("http")) {    if (v.includes("&")) v = v.split("&")[0];    if (v.includes("?")) v = v.split("?")[0];    return v;  }  try {    // Tieni solo il primo parametro di query    if (v.includes("?")) {      const [base, q] = v.split("?");      v = `${base}?${q.split("&")[0]}`;    }    const url = new URL(v);    // youtu.be/VIDEOID    if (url.hostname.includes("youtu.be")) {      let id = url.pathname.replace("/", "");      if (id.includes("?")) id = id.split("?")[0];      if (id.includes("&")) id = id.split("&")[0];      return id;    }    // youtube.com/watch?v=VIDEOID    if (url.hostname.includes("youtube.com")) {      let id = url.searchParams.get("v");      if (!id) return null;      if (id.includes("&")) id = id.split("&")[0];      if (id.includes("?")) id = id.split("?")[0];      return id;    }  } catch {    if (v.includes("&")) v = v.split("&")[0];    if (v.includes("?")) v = v.split("?")[0];    return v;  }  if (v.includes("&")) v = v.split("&")[0];  if (v.includes("?")) v = v.split("?")[0];  return v;}// ======================================================================// üîß TimedText YouTube ‚Üí testo continuo// ======================================================================function vttToPlainText(raw) {  if (!raw) return "";  const lines = raw.replace(/\r/g, "").split("\n").map((l) => l.trim());  const clean = lines.filter((line) => {    if (!line) return false;    if (/^\d+$/.test(line)) return false;                // sequenza numerica    if (line.includes("-->")) return false;              // timestamp    if (/^(WEBVTT|Kind:|Language:)/i.test(line)) return false;    return true;  });  return clean.join(" ").replace(/\s+/g, " ").trim();}async function fetchTimedText(videoId, lang) {  const url = `https://www.youtube.com/api/timedtext?lang=${lang}&v=${videoId}&fmt=vtt`;  try {    const res = await fetch(url);    if (!res.ok) return null;    return await res.text();  } catch {    return null;  }}async function tryTimedText(videoId, debug = false) {  const langs = (process.env.TRANSCRIPT_LANGS || "it,en")    .split(",")    .map((x) => x.trim())    .filter(Boolean);  for (const lang of langs) {    if (debug) console.log(`üîé TimedText ‚Üí ${videoId} [${lang}]`);    const raw = await fetchTimedText(videoId, lang);    if (!raw) continue;    const plain = vttToPlainText(raw);    if (plain && plain.length > 50) {      if (debug) console.log(`‚úÖ TimedText OK (${lang})`);      return { provider: `youtube-timedtext-${lang}`, plain };    }  }  return null;}// ======================================================================// üîß Proxy esterno (es. tuo micro-servizio transcript)// ======================================================================async function tryProxy(videoId, debug = false) {  const base = process.env.YT_TRANSCRIPT_PROXY_URL;  if (!base) return null;  const url = `${base}?v=${encodeURIComponent(videoId)}`;  try {    if (debug) console.log(`üîé Proxy transcript ‚Üí ${url}`);    const res = await fetch(url);    if (!res.ok) return null;    const data = await res.json().catch(() => null);    if (!data) return null;    const t = data.continuousText || data.text || "";    if (!t || t.trim().length < 50) return null;    if (debug) console.log("‚úÖ Proxy transcript OK");    return { provider: "proxy", plain: t.trim() };  } catch {    return null;  }}// ======================================================================// üîß YouTube Summary API esterna (YT_SUMMARY_API_URL)//    Questa √® la parte che pu√≤ usare ‚ÄúYouTube Summary‚Äù o simili,//    via un tuo endpoint intermedio.// ======================================================================async function trySummaryApi(videoId, debug = false) {  const base = process.env.YT_SUMMARY_API_URL;  if (!base) return null;  const url = `${base}?videoId=${encodeURIComponent(videoId)}`;  try {    if (debug) console.log(`üîé Summary API ‚Üí ${url}`);    const res = await fetch(url);    if (!res.ok) return null;    const data = await res.json().catch(() => null);    if (!data) return null;    let summary = "";    if (typeof data.summary === "string") summary = data.summary;    else if (typeof data.text === "string") summary = data.text;    else if (Array.isArray(data.bullets)) summary = data.bullets.join(" ");    else if (Array.isArray(data.sentences)) summary = data.sentences.join(" ");    if (!summary || summary.trim().length < 30) return null;    if (debug) console.log("‚úÖ Summary API OK");    return summary.trim();  } catch {    return null;  }}// ======================================================================// üîß Scraper HTML YouTube + noembed// ======================================================================async function fetchNoembed(videoId) {  try {    const url = `https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`;    const res = await fetch(url);    if (!res.ok) return null;    return await res.json();  } catch {    return null;  }}function extractDesc(html) {  if (!html) return null;  // shortDescription nello script JSON  const j = html.match(/"shortDescription":"(.*?)"/s);  if (j && j[1]) {    return j[1]      .replace(/\\n/g, " ")      .replace(/\\r/g, " ")      .replace(/\\"/g, '"')      .replace(/\\\\/g, "\\")      .trim();  }  // meta description  const m = html.match(/<meta\s+name="description"\s+content="([^"]*)"/i);  if (m && m[1]) return m[1].trim();  return null;}function extractTitle(html) {  if (!html) return null;  const m = html.match(/<title>(.*?)<\/title>/i);  if (m && m[1]) {    return m[1].replace(/\s+-\s+YouTube$/i, "").trim();  }  return null;}async function fetchHtml(videoId) {  try {    const url = `https://www.youtube.com/watch?v=${videoId}`;    const res = await fetch(url);    if (!res.ok) return null;    return await res.text();  } catch {    return null;  }}async function scrapeContext(videoId, debug = false) {  const [noembed, html] = await Promise.all([    fetchNoembed(videoId),    fetchHtml(videoId),  ]);  const title =    (noembed && noembed.title) ||    (html && extractTitle(html)) ||    null;  const author = (noembed && noembed.author_name) || null;  const description = html ? extractDesc(html) : null;  const htmlSnippet = html ? html.slice(0, 8000) : null;  if (debug) {    console.log("üîç SCRAPER CONTEXT:", {      title,      author,      descPreview: description ? description.slice(0, 100) : null,    });  }  return { title, author, description, htmlSnippet };}// ======================================================================// üîß Summary interno via AI (tipo "YouTube Summary" interno)// ======================================================================async function trySummaryInternal(videoId, debug = false) {  const ctx = await scrapeContext(videoId, debug);  const { title, description } = ctx;  if (!title && !description) return null;  const systemPrompt =    "Riassumi in 10-15 frasi brevi e chiare il probabile contenuto di questo video YouTube, basandoti su titolo e descrizione. Non inventare cose assurde, ma sii verosimile.";  const userPrompt = `Titolo: ${title || "(non disponibile)"}Descrizione:${description || "(nessuna descrizione)"}`.trim();  try {    if (debug) console.log("üß† Summary interno: chiamata modello...");    const aiRaw = await callAIModel({      model: process.env.AI_SUMMARY_MODEL || "gpt-4o-mini",      temperature: 0.4,      maxTokens: 1500,      systemPrompt,      userPrompt,    });    const txt = String(      typeof aiRaw === "string" ? aiRaw : aiRaw?.content || aiRaw?.text || ""    ).trim();    if (!txt || txt.length < 50) return null;    if (debug) console.log("‚úÖ Summary interno OK (len:", txt.length, ")");    return txt;  } catch {    return null;  }}// ======================================================================// üîß AI Transcript Rebuild (con contesto + summary)// ======================================================================async function rebuildTranscript(videoId, ctx, summary, debug = false) {  const systemPrompt = `Sei un assistente che ricostruisce transcript verosimili di video YouTubeper analisi strategiche. Usa tutti i dati disponibili (titolo, autore, descrizione,summary testuale, snippet HTML) per creare un transcript continuo, naturale, plausibile,in italiano se possibile. Non scrivere commenti, solo il testo del transcript.`.trim();  const parts = [];  parts.push(`Video ID: ${videoId}`);  if (ctx?.title) parts.push(`Titolo: ${ctx.title}`);  if (ctx?.author) parts.push(`Autore/Canale: ${ctx.author}`);  if (ctx?.description) parts.push(`Descrizione YouTube:\n${ctx.description}`);  if (summary) parts.push(`Riassunto disponibile:\n${summary}`);  if (ctx?.htmlSnippet) parts.push(`Snippet HTML (estratto dalla pagina YouTube):\n${ctx.htmlSnippet}`);  parts.push("Ricostruisci il possibile transcript parlato del video, con frasi complete e scorrevoli.");  const userPrompt = parts.join("\n\n");  try {    if (debug) console.log("üß† AI REBUILD: chiamata modello...");    const aiRaw = await callAIModel({      model: process.env.AI_TRANSCRIPT_REBUILD_MODEL || "gpt-4o-mini",      temperature: 0.5,      maxTokens: 6000,      systemPrompt,      userPrompt,    });    const txt = String(      typeof aiRaw === "string" ? aiRaw : aiRaw?.content || aiRaw?.text || ""    ).trim();    if (!txt || txt.length < 50) {      if (debug) console.log("‚ö†Ô∏è AI REBUILD ha prodotto testo corto/vuoto.");      return null;    }    if (debug) console.log("‚úÖ AI REBUILD OK (len:", txt.length, ")");    return txt;  } catch {    return null;  }}// ======================================================================// üîß Fallback testuale generico (mai errori duri)// ======================================================================async function genericFallbackTranscript(videoId) {  return `Transcript non disponibile per il video ${videoId}. L'AI non √® riuscita a ricostruire il parlato. Incolla manualmente la trascrizione da YouTube dentro Zen YouTube Coach Pro per analisi pi√π accurate.`;}// ======================================================================// üîß AI Cleanup finale// ======================================================================async function cleanupTranscript(text) {  if (!text || text.length < 20) return null;  const systemPrompt = `Ripulisci questo transcript:- sistema la punteggiatura,- unisci frasi spezzate,- non aggiungere concetti nuovi,- non cambiare lingua.Rispondi solo con il testo pulito.`.trim();  const userPrompt = text;  try {    const aiRaw = await callAIModel({      model: process.env.AI_TRANSCRIPT_CLEAN_MODEL || "gpt-4o-mini",      temperature: 0.1,      maxTokens: 4000,      systemPrompt,      userPrompt,    });    const out = String(      typeof aiRaw === "string" ? aiRaw : aiRaw?.content || aiRaw?.text || ""    ).trim();    if (!out || out.length < 20) return null;    return out;  } catch {    return null;  }}// ======================================================================// üß† PIPELINE PRINCIPALE AUTOMATICA// ======================================================================async function resolvePipeline(videoId, options = {}) {  const debug = !!options.debug;  if (debug) console.log(`üöÄ PIPELINE V6 ‚Üí videoId = ${videoId}`);  // 1) TimedText  const timed = await tryTimedText(videoId, debug);  if (timed) {    const cleaned = await cleanupTranscript(timed.plain);    return { provider: timed.provider, text: cleaned || timed.plain };  }  // 2) Proxy  const proxy = await tryProxy(videoId, debug);  if (proxy) {    const cleaned = await cleanupTranscript(proxy.plain);    return { provider: proxy.provider, text: cleaned || proxy.plain };  }  // 3) Summary (manuale, API, interno)  let summary = null;  if (options.manualSummary && options.manualSummary.trim().length > 0) {    summary = options.manualSummary.trim();    if (debug) console.log("üìù Uso manualSummary fornito dall'utente.");  } else {    summary =      (await trySummaryApi(videoId, debug)) ||      (await trySummaryInternal(videoId, debug));  }  // 4) Scraper contesto + AI Rebuild  const ctx = await scrapeContext(videoId, debug);  const rebuilt = await rebuildTranscript(videoId, ctx, summary, debug);  if (rebuilt) {    const cleaned = await cleanupTranscript(rebuilt);    return {      provider: summary ? "ai-rebuild-with-summary" : "ai-rebuild",      text: cleaned || rebuilt,    };  }  // 5) Fallback generico (ma SEMPRE testo, mai errore duro)  const fallback = await genericFallbackTranscript(videoId);  return { provider: "fallback-generic", text: fallback };}// ======================================================================// üü¢ ENTRYPOINT PUBBLICO// ======================================================================//// getTranscript(videoIdOrUrl, {//   manualTranscript?: string,//   manualSummary?: string,//   forceRefresh?: boolean,//   debug?: boolean// })//// ======================================================================export async function getTranscript(videoIdOrUrl, options = {}) {  const {    manualTranscript,    manualSummary,    forceRefresh = false,    debug = false,  } = options;  const videoId = normalizeVideoId(videoIdOrUrl);  if (!videoId) {    return {      success: false,      error: true,      message: "videoId non valido.",    };  }  // 1) manualTranscript ‚Üí PRIORITARIO (quello che incolli tu da YouTube)  if (manualTranscript && manualTranscript.trim().length > 20) {    const text = manualTranscript.trim();    const cleaned = await cleanupTranscript(text);    const final = cleaned || text;    const out = {      success: true,      error: false,      provider: "manual",      videoId,      continuousText: final,      aiText: cleaned || null,      timestamp: new Date().toISOString(),    };    transcriptCache.set(videoId, out);    return out;  }  // 2) Cache  if (!forceRefresh && transcriptCache.has(videoId)) {    return { ...transcriptCache.get(videoId), fromCache: true };  }  // 3) Pipeline automatica  const result = await resolvePipeline(videoId, { manualSummary, debug });  const out = {    success: true,    error: false,    provider: result.provider,    videoId,    continuousText: result.text,    aiText: null,    timestamp: new Date().toISOString(),  };  transcriptCache.set(videoId, out);  return out;}// Tools opzionaliexport function clearTranscriptCache() {  transcriptCache.clear();}export function getTranscriptCacheSize() {  return transcriptCache.size;}